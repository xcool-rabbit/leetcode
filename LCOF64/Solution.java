// 剑指 Offer 64. 求1+2+…+n
/*
  妙哇，首先这个不让用乘法和循环，所以我能想到的应该只有递归了
  但是问题在于，递归需要判断语句，这个连判断都不能用，那我是真想不到了
  只能看题解，题解提到了逻辑运算符的短路
  比如用&&运算符，前面放n > 0，后面的语句只会在n > 0的情况下才执行
  这样堪比if语句了！
  那么后面一定是一个永远是true的判断
  后面是一个n的赋值语句
  最后返回n！
  太妙啦
  执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
*/
class Solution {
    public int sumNums(int n) {
        boolean tmp = n > 0 && (n += sumNums(n - 1)) > 0;
        return n;
    }
}
